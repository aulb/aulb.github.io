{"version":3,"sources":["webpack:///path---posts-implement-hashtable-a49a6f44ff63e6a0de91.js","webpack:///./.cache/json/posts-implement-hashtable.json"],"names":["webpackJsonp","390","module","exports","data","markdownRemark","html","frontmatter","title","date","language","categories","helper","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,6/DAAAC,aAAmhEC,MAAA,aAAAC,KAAA,kBAAAC,SAAA,UAAAC,WAAA,YAAAC,OAAA,QAA4GC,aAAgBC,KAAA","file":"path---posts-implement-hashtable-a49a6f44ff63e6a0de91.js","sourcesContent":["webpackJsonp([243791445308597],{\n\n/***/ 390:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>I've been studying interview questions for the past couple of weeks. One that I came across quite a few time was the infamous describe (and or implement) the inner workings of hash tables.</p>\\n<p>I thought it'd be interesting to explore this problem with my favourite programming language Python.</p>\\n<h1>What is a Hash Table?</h1>\\n<p>In Python, hash tables are called dictionaries, and they are a key/value pair storage.</p>\\n<h1>How to implement a simple hash table</h1>\\n<p>Using Python's data structure.</p>\\n<h1>Inner working of dictionaries</h1>\\n<h1>Basic Fields</h1>\\n<p><code>ma_used</code>\\n<code>ma_fill</code>\\n<code>ma_mask</code>\\n<code>ma_table</code></p>\\n<p>How does this hash function work exactly???\\nWhy <code>ma_fill</code> the same number when a key is deleted? Whats the purpose? </p>\\n<h1>What do you get from objects?</h1>\\n<h1>What did I learn from reading?</h1>\\n<h1>Inserting</h1>\\n<h1>Deleting</h1>\\n<p>Never resized down on deletion\\nThis usage pattern is quite infrequent, thus why is the one pursued\\nno-resize-on-deletion policy</p>\\n<h1>Exploring mapping and collision, I'm sure this gets asked tons of time.</h1>\\n<ul>\\n<li>\\n<p>Chaining: Each slot is the head of a linked list containing all the items that hash to that slot (my school taught me this)\\nMemory allocation is a slow operation, yep malloc</p>\\n</li>\\n<li>\\n<p>Linear scan: When hit a collision\\nSome complicated </p>\\n</li>\\n<li>\\n<p>Python scan:\\n<em>trick here</em>\\nWhy 5? Great question.</p>\\n</li>\\n</ul>\\n<h1>Resizing</h1>\\n<p>Load factor\\n-We know from the readings that the table size is always a power of two- not true\\nn/(2/3),</p>\\n<p>re organize??? no</p>\\n<p>resizing when 2/3d full\\nma<em>used * 4 for fewer elements\\nma</em>used * 2 for more than 50k keys</p>\\n<h1>Tricks</h1>\\n<p>Memory tradeoff\\nquestion: are the dictionaries the same size?</p>\\n<h1>Iterating through, yield, generators</h1>\\n<p>Turns out that generators in Python is memory efficient as well</p>\\n<p>I learned that they do a bunch of weird things</p>\",\"frontmatter\":{\"title\":\"Hashtables\",\"date\":\"August 30, 2016\",\"language\":\"english\",\"categories\":\"hashtable\",\"helper\":null}}},\"pathContext\":{\"slug\":\"/posts/implement-hashtable/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-implement-hashtable-a49a6f44ff63e6a0de91.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>I've been studying interview questions for the past couple of weeks. One that I came across quite a few time was the infamous describe (and or implement) the inner workings of hash tables.</p>\\n<p>I thought it'd be interesting to explore this problem with my favourite programming language Python.</p>\\n<h1>What is a Hash Table?</h1>\\n<p>In Python, hash tables are called dictionaries, and they are a key/value pair storage.</p>\\n<h1>How to implement a simple hash table</h1>\\n<p>Using Python's data structure.</p>\\n<h1>Inner working of dictionaries</h1>\\n<h1>Basic Fields</h1>\\n<p><code>ma_used</code>\\n<code>ma_fill</code>\\n<code>ma_mask</code>\\n<code>ma_table</code></p>\\n<p>How does this hash function work exactly???\\nWhy <code>ma_fill</code> the same number when a key is deleted? Whats the purpose? </p>\\n<h1>What do you get from objects?</h1>\\n<h1>What did I learn from reading?</h1>\\n<h1>Inserting</h1>\\n<h1>Deleting</h1>\\n<p>Never resized down on deletion\\nThis usage pattern is quite infrequent, thus why is the one pursued\\nno-resize-on-deletion policy</p>\\n<h1>Exploring mapping and collision, I'm sure this gets asked tons of time.</h1>\\n<ul>\\n<li>\\n<p>Chaining: Each slot is the head of a linked list containing all the items that hash to that slot (my school taught me this)\\nMemory allocation is a slow operation, yep malloc</p>\\n</li>\\n<li>\\n<p>Linear scan: When hit a collision\\nSome complicated </p>\\n</li>\\n<li>\\n<p>Python scan:\\n<em>trick here</em>\\nWhy 5? Great question.</p>\\n</li>\\n</ul>\\n<h1>Resizing</h1>\\n<p>Load factor\\n-We know from the readings that the table size is always a power of two- not true\\nn/(2/3),</p>\\n<p>re organize??? no</p>\\n<p>resizing when 2/3d full\\nma<em>used * 4 for fewer elements\\nma</em>used * 2 for more than 50k keys</p>\\n<h1>Tricks</h1>\\n<p>Memory tradeoff\\nquestion: are the dictionaries the same size?</p>\\n<h1>Iterating through, yield, generators</h1>\\n<p>Turns out that generators in Python is memory efficient as well</p>\\n<p>I learned that they do a bunch of weird things</p>\",\"frontmatter\":{\"title\":\"Hashtables\",\"date\":\"August 30, 2016\",\"language\":\"english\",\"categories\":\"hashtable\",\"helper\":null}}},\"pathContext\":{\"slug\":\"/posts/implement-hashtable/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-implement-hashtable.json\n// module id = 390\n// module chunks = 243791445308597"],"sourceRoot":""}